<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchical SBOM Dependency Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars on body */
        }
        .node circle {
            stroke: #333;
            stroke-width: 1.5px;
        }
        .node text {
            font-size: 11px;
            paint-order: stroke;
            stroke: #fff;
            stroke-width: 3px;
            stroke-linecap: butt;
            stroke-linejoin: round;
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }
        .link.vulnerable {
            stroke: #FF5252; /* Red */
            stroke-width: 2px;
        }
        .link.dependent {
            stroke: #FFA500; /* Orange */
            stroke-width: 2px;
        }
        .tooltip {
            position: absolute;
            padding: 15px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            pointer-events: auto; /* Allow interaction */
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            max-width: 400px;
            min-width: 200px;
            transition: opacity 0.2s ease;
            z-index: 1000;
            max-height: 80vh; /* Limit height */
            overflow-y: auto; /* Add scroll if needed */
            scrollbar-width: thin;
            scrollbar-color: rgba(0,0,0,0.2) transparent;
            opacity: 0; /* Start hidden */
            display: none; /* Start not displayed */
        }

        /* Webkit scrollbar styling */
        .tooltip::-webkit-scrollbar {
            width: 8px;
        }

        .tooltip::-webkit-scrollbar-track {
            background: transparent;
        }

        .tooltip::-webkit-scrollbar-thumb {
            background-color: rgba(0,0,0,0.2);
            border-radius: 4px;
        }

        .tooltip::-webkit-scrollbar-thumb:hover {
            background-color: rgba(0,0,0,0.3);
        }

        .tooltip h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
            word-wrap: break-word;
        }

        .tooltip p {
            margin: 5px 0;
            color: #666;
            word-wrap: break-word;
        }

        .tooltip .vulnerability-info {
            background-color: #fff5f5;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            word-wrap: break-word;
        }

        .tooltip .vulnerability-info h5 {
            color: #d32f2f;
            margin: 0 0 5px 0;
            font-size: 14px;
        }

        /* Use ul/li styling defined within vulnerability-item */
        .tooltip .vulnerability-info ul {
            margin: 0;
            padding-left: 0; /* Remove default padding */
            list-style-type: none; /* Remove default bullets */
        }

        /* Re-added rule for specific vuln li styling */
        .tooltip .vulnerability-info li {
            margin: 3px 0;
            color: #d32f2f; /* Make vuln text red */
            word-wrap: break-word;
        }

        .tooltip .dependency-warning {
            background-color: #fff8e1;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            word-wrap: break-word;
            border-left: 3px solid #ff8f00; /* Added border like hierarchical */
        }

        .tooltip .dependency-warning h5 {
            color: #ff8f00;
            margin: 0 0 5px 0;
            font-size: 14px;
        }
         /* Added paragraph styling for dependency warning */
         .tooltip .dependency-warning p {
             color: #665b3e; /* Darker text for yellow background */
             margin: 0;
             font-size: 0.95em;
        }

        .tooltip .license-info {
            background-color: #f3e5f5;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            word-wrap: break-word;
        }

        .tooltip .license-info h5 {
            color: #7b1fa2;
            margin: 0 0 5px 0;
            font-size: 14px;
        }

        /* Removed .warning-icon as it's not used in hierarchical */

        /* vulnerability-item and sub-elements define detailed styling */
        .vulnerability-item {
            margin-bottom: 15px;
            padding: 10px;
            background: #fff5f5; /* Consistent background */
            border-radius: 4px;
            border-left: 3px solid #ff5252;
            color: #666; /* Base text color */
        }

        .vulnerability-header {
            margin-bottom: 8px;
        }
        .vulnerability-header strong { /* Style for vuln ID */
            color: #d32f2f;
            display: block;
            margin-bottom: 5px;
            font-size: 1.05em;
        }

        .cvss-info {
            margin: 5px 0;
            font-size: 0.9em;
            color: #666;
        }
        .cvss-info strong {
             color: #333;
        }
        .cvss-info small {
             color: #888; /* Lighter Grey for vector */
             display: block;
             margin-top: 3px;
         }

        .vulnerability-dates {
            color: #888; /* Lighter grey for dates */
            font-size: 0.8em;
            margin: 5px 0;
        }
         .vulnerability-dates small {
             display: block;
             margin-bottom: 3px;
         }

        .vulnerability-description {
            margin: 8px 0;
            line-height: 1.4;
            color: #666;
        }

        .references {
            margin-top: 8px;
            font-size: 0.9em;
            color: #666;
        }
        .references strong {
            color: #333;
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
         }

        .references ul {
            margin: 5px 0;
            padding-left: 15px; /* Ensure padding for bullets */
            list-style-type: disc; /* Ensure bullets */
        }
        .references li {
             margin: 3px 0;
             color: #666; /* Ensure list item text color */
         }

        .references a {
            color: #0066cc;
            text-decoration: none;
            word-break: break-all;
        }

        .references a:hover {
            text-decoration: underline;
        }

        /* Style for vulnerable nodes */
        .node.vulnerable circle {
            fill: #FF5252; /* Ensure fill is red */
            /* Optional: Add distinct stroke if needed */
            /* stroke: #CC4242; */
            /* stroke-width: 2.5px; */
        }
        /* Style for dependent nodes */
        .node.dependent circle {
            fill: #FFA500; /* Orange fill */
            /* stroke: #CC8400; */
        }
    </style>
</head>
<body>
    <svg width="100%" height="100%"></svg>
    <div class="tooltip"></div>

    <script>
        // --- Data ---
        // This placeholder will be replaced by the actual JSON data from Python
        const graphData = {{GRAPH_DATA}};

        // --- Setup ---
        const svg = d3.select("svg");
        const width = window.innerWidth;
        const height = window.innerHeight;
        const tooltip = d3.select(".tooltip");

        svg.attr("viewBox", [0, 0, width, height]);

        const g = svg.append("g")
            .attr("transform", `translate(60, 40)`); // Increased left padding for labels

        // --- Layout ---
        const nodeWidth = 180; // Increased spacing between nodes horizontally (depth)
        const nodeHeight = 35; // Increased spacing between nodes vertically
        // Use d3.tree for a tidy tree layout
        const treeLayout = d3.tree()
            .nodeSize([nodeHeight, nodeWidth]); // Use nodeSize for better control over spacing

        const root = d3.hierarchy(graphData);
        // Assign initial coordinates - treeLayout modifies these
        // These are for potential animation, not strictly necessary for layout
        // root.x0 = height / 2;
        // root.y0 = 0;

        // Collapse children beyond a certain depth initially (optional)
        // root.descendants().forEach((d, i) => {
        //     if (d.depth >= 3) d._children = d.children;
        //     if (d.depth >= 3) d.children = null;
        // });

        treeLayout(root);

        // --- Calculate Depth for Layers ---
        let minX = Infinity, maxX = -Infinity;
        root.each(d => {
          if (d.x < minX) minX = d.x;
          if (d.x > maxX) maxX = d.x;
        });

        let minY = Infinity, maxY = -Infinity;
        let maxDepth = 0;
        const descendants = root.descendants();
        descendants.forEach(d => {
            if (d.y < minY) minY = d.y; // d.y represents depth in horizontal tree
            if (d.y > maxY) maxY = d.y;
            if (d.depth > maxDepth) maxDepth = d.depth;
        });

        const layerDepths = Array.from({ length: maxDepth + 1 }, (_, i) => {
            const nodesAtDepth = descendants.filter(d => d.depth === i);
            // Use the y-coordinate (depth) of the first node at this depth
            return nodesAtDepth.length > 0 ? nodesAtDepth[0].y : null;
        }).filter(y => y !== null);


        // --- Layer Separators ---
        const layerGroup = g.insert("g", ":first-child") // Insert behind links and nodes
            .attr("class", "layers");

        layerDepths.forEach((layerY, i) => {
            const lineY = layerY - nodeWidth / 2; // Position line between layers
            if (i > 0) { // Don't draw line before the first layer
                 layerGroup.append("line")
                    .attr("class", "layer-separator")
                    .attr("x1", lineY)
                    .attr("y1", minX - nodeHeight) // Extend slightly above top node
                    .attr("x2", lineY)
                    .attr("y2", maxX + nodeHeight) // Extend slightly below bottom node
                    .attr("stroke", "#e0e0e0")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "3,3");
            }

            // Add Layer Label
            layerGroup.append("text")
                .attr("class", "layer-label")
                .attr("x", layerY) // Center label on the layer's nodes
                .attr("y", minX - nodeHeight * 1.5) // Position above the graph
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "#666")
                .text(`Layer ${i}`);

        });


        // --- Links ---
        const linkGenerator = d3.linkHorizontal()
            .x(d => d.y) // Depth corresponds to y in horizontal tree
            .y(d => d.x); // Spread corresponds to x in horizontal tree

        g.append("g")
            .attr("class", "links")
            .selectAll("path")
            .data(root.links())
            .join("path")
            .attr("class", "link")
            // Determine link class based on target node status
            .classed("vulnerable", d => d.target.data.isVulnerable)
            .classed("dependent", d => !d.target.data.isVulnerable && d.target.data.isDependentOnVulnerable)
            .attr("d", linkGenerator);

        // --- Nodes ---
        const node = g.append("g")
            .attr("class", "nodes")
            .selectAll("g")
            .data(root.descendants())
            .join("g")
            .attr("class", d => `node ${d.data.isVulnerable ? 'vulnerable' : d.data.isDependentOnVulnerable ? 'dependent' : ''} ${d.data.type ? d.data.type.toLowerCase() : 'unknown'}`)
            .attr("transform", d => `translate(${d.y},${d.x})`)
            .each(function(d) { // Use .each to append elements to each node group
                const nodeGroup = d3.select(this);

                nodeGroup.append("circle")
                    .attr("r", d.data.size ? Math.max(d.data.size / 5, 5) : 7)
                    .attr("fill", d.data.color || '#999')
                    .style("stroke", () => {
                        // Re-apply correct GNN Border Color Logic with Confidence Shading
                        if (!d.data || d.data.type === 'LICENSE' || d.data.gnnConfidence === undefined) {
                            return '#6c757d'; // Default for non-library nodes or missing confidence
                        }

                        const confidence = d.data.gnnConfidence || 0;
                        // New Interpolator: Bright Green (#90EE90) to Dark Red (#B22222 - Firebrick, adjust as needed)
                        const colorInterpolator = d3.interpolateRgb("#90EE90", "#B22222");
                        const borderColor = colorInterpolator(confidence);
                        return borderColor; // Color based only on confidence
                    })
                    .attr("stroke-width", () => {
                        if (!d.data || d.data.type === 'LICENSE') return 1.5;
                        // Keep stroke width emphasis if there's *any* valid GNN info
                        return (d.data.gnnConfidence !== undefined && d.data.gnnPrediction !== 'Unknown' && d.data.gnnPrediction !== 'Error') ? 2.5 : 1.5;
                    })
                    .attr("stroke-dasharray", () => {
                        // Restore original logic
                        if (!d.data || d.data.type === 'LICENSE') return null;
                        // Keep dash pattern if there's *any* valid GNN info
                        return (d.data.gnnConfidence !== undefined && d.data.gnnPrediction !== 'Unknown' && d.data.gnnPrediction !== 'Error') ? "4,4" : null;
                    });
                    // Ensure stroke-opacity is removed

                nodeGroup.append("text")
                    .attr("dy", "0.31em")
                    .attr("x", d.children ? -( (d.data.size ? Math.max(d.data.size / 5, 5) : 7) + 5) : ( (d.data.size ? Math.max(d.data.size / 5, 5) : 7) + 5) )
                    .attr("text-anchor", d.children ? "end" : "start")
                    .text(d.data.label);
            }); // End of .each block

        // --- Tooltip Interaction ---
        let tooltipTimeout; // Variable to hold the timeout ID

        // Select the nodes again for attaching event listeners
        g.selectAll('.node').on("mouseover", function(event, d) {
            clearTimeout(tooltipTimeout); // Clear any pending hide timer
            tooltip.style("pointer-events", "auto");// Make interactive
            tooltip.style("display", "block");      // Make visible

            // --- Build Tooltip Content (Matching Force-Directed) ---
            let tooltipContent = `<h4>${d.data.fullLabel || d.data.name}</h4>`;

            // Add description if available
            if (d.data.description) {
                tooltipContent += `<p>${d.data.description}</p>`;
            }

             // Add License Info (basic example from hierarchical, can be expanded)
            if (d.data.licenses && d.data.licenses.length > 0) {
                tooltipContent += `
                    <div class="license-info">
                        <h5>License Information</h5>
                        <p>License(s): ${d.data.licenses.map(l => l.name || l.id).join(', ')}</p>
                         <!-- Add more license details here if needed -->
                    </div>`;
            }

            // --- GNN Prediction Info (moved here) ---
            if (d.data.type !== 'LICENSE' && d.data.gnnPrediction && d.data.gnnPrediction !== 'Unknown' && d.data.gnnPrediction !== 'Error') {
                const confidencePercent = (d.data.gnnConfidence * 100).toFixed(1);
                let gnnColor = d.data.gnnPrediction === 'Vulnerable' ? '#E69500' : '#28a745';
                tooltipContent += `
                    <div class="gnn-analysis">
                        <h5>GNN Analysis</h5>
                        <p>Prediction: <strong style="color:${gnnColor};">${d.data.gnnPrediction}</strong></p>
                        <p>Confidence: ${confidencePercent}%</p>
                    </div>`;
            } else if (d.data.type !== 'LICENSE') {
                 tooltipContent += `
                    <div class="gnn-analysis">
                        <h5>GNN Analysis</h5>
                        <p>Prediction: Not Available</p>
                    </div>`;
            }
            // --- End GNN Prediction Info ---

            // Handle Vulnerable Nodes
            if (d.data.isVulnerable && d.data.vulnerabilities && d.data.vulnerabilities.length > 0) {
                tooltipContent += `
                    <div class="vulnerability-info">
                        <h5>Vulnerability Details</h5>
                        <ul>`; // Start the list for vulnerabilities

                d.data.vulnerabilities.forEach(vuln => {
                    // Format dates
                    // Handle potential date strings or null values gracefully
                    const publishedDate = vuln.published_date || vuln.published
                        ? new Date(vuln.published_date || vuln.published).toLocaleDateString()
                        : 'Unknown';
                    const modifiedDate = vuln.modified_date || vuln.updated
                        ? new Date(vuln.modified_date || vuln.updated).toLocaleDateString()
                        : 'Unknown';


                    // Format CVSS info
                    let cvssInfo = '';
                    // Check if *any* CVSS related field exists
                    if (vuln.cvss_score !== undefined || vuln.cvss_severity || vuln.cvss_vector) {
                         cvssInfo = `
                            <div class="cvss-info">
                                <strong>CVSS:</strong> ${vuln.cvss_score !== undefined ? vuln.cvss_score : 'N/A'} (${vuln.cvss_severity || 'Unknown'})<br>
                                <small>Vector: ${vuln.cvss_vector || 'N/A'}</small>
                            </div>`;
                    }

                    // Format references
                    let referencesHtml = '';
                    if (vuln.references && vuln.references.length > 0) {
                        referencesHtml = `
                            <div class="references">
                                <strong>References:</strong>
                                <ul>`;
                        // Adapt reference handling: force-directed expects {type, url}, hierarchical might just have URLs
                        vuln.references.forEach(ref => {
                            if (typeof ref === 'object' && ref.url) { // Handle object refs like {type: 'WEB', url: '...'}
                                 referencesHtml += `<li><a href="${ref.url}" target="_blank">${ref.type || 'Link'}: ${ref.url}</a></li>`;
                            } else if (typeof ref === 'string') { // Handle simple URL string refs
                                 referencesHtml += `<li><a href="${ref}" target="_blank">${ref}</a></li>`;
                            }
                        });
                        referencesHtml += `</ul></div>`;
                    }

                    tooltipContent += `
                        <li class="vulnerability-item">
                            <div class="vulnerability-header">
                                <strong>${vuln.id || vuln.source_id || 'Unknown ID'}</strong>
                                ${cvssInfo}
                            </div>
                            <div class="vulnerability-dates">
                                <small>Published: ${publishedDate}</small>
                                <small>Modified: ${modifiedDate}</small>
                            </div>
                            <div class="vulnerability-description">
                                ${vuln.description || 'No description available.'}
                            </div>
                            ${vuln.recommendation ? `<small><em>Recommendation:</em> ${vuln.recommendation}</small><br/>` : ''}
                            ${vuln.status ? `<small>Status: ${vuln.status}</small><br/>` : ''}
                            ${(vuln.fixed_versions && vuln.fixed_versions.length > 0 && vuln.fixed_versions[0]) ? `<small>Fix: ${vuln.fixed_versions.join(', ')}</small><br/>` : ''}
                            ${referencesHtml}
                        </li>`;
                });

                tooltipContent += `</ul></div>`; // Close vulnerability-info div
            } else if (d.data.isVulnerable) {
                 // Case where node is marked vulnerable but no details provided
                 tooltipContent += `
                     <div class="vulnerability-info">
                         <h5>Vulnerability Details</h5>
                         <p>Marked as vulnerable, but specific details are not available.</p>
                     </div>`;
            }

            // Handle Dependent Nodes (Warning - only if NOT also vulnerable)
            if (d.data.isDependentOnVulnerable && !d.data.isVulnerable) {
                tooltipContent += `
                    <div class="dependency-warning">
                        <h5>Dependency Warning</h5>
                        <p>This package depends on other vulnerable components.</p>
                    </div>`;
            } else if (!d.data.isVulnerable && !d.data.isDependentOnVulnerable && d.data.type !== 'LICENSE') {
                // Only show 'no known vulns' if it's a component and not already covered
                tooltipContent += `<p>No known vulnerabilities impacting this package directly or indirectly at this time.</p>`;
            }

            tooltip.html(tooltipContent);

            // --- Tooltip Positioning (Matching Force-Directed) ---
            const tooltipRect = tooltip.node().getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            let left = event.pageX + 15; // Offset slightly from cursor
            let top = event.pageY - 15; // Offset slightly from cursor

            // Adjust if tooltip goes off-screen right
            if (left + tooltipRect.width > windowWidth - 10) { // Add small buffer
                left = windowWidth - tooltipRect.width - 10;
            }
            // Adjust if tooltip goes off-screen bottom
            if (top + tooltipRect.height > windowHeight - 10) { // Add small buffer
                top = windowHeight - tooltipRect.height - 10;
            }
             // Adjust if tooltip goes off-screen left (less common)
            if (left < 10) {
                left = 10;
            }
            // Adjust if tooltip goes off-screen top
            if (top < 10) {
                top = 10;
            }


            tooltip
                .style("left", left + "px")
                .style("top", top + "px");

             // Start fade-in transition
            tooltip.transition()
                .duration(200)
                .style("opacity", 0.95);

        })
        .on("mouseout", function(event, d) {
             // Start timer to hide tooltip after a small delay
            tooltipTimeout = setTimeout(() => {
                 tooltip.style("pointer-events", "none"); // Make non-interactive immediately
                 tooltip.transition() // Add transition for fade out
                    .duration(300)
                    .style("opacity", 0)
                    .on("end", function() {
                        // Check opacity again in case a show was triggered during fade-out
                         if (+d3.select(this).style("opacity") === 0) {
                           d3.select(this).style("display", "none"); // Hide after fade
                         }
                    });
            }, 200); // 200ms delay
        });

        // Add handlers for the tooltip itself to prevent hiding when mouse is over it
        tooltip.on("mouseover", function() {
            clearTimeout(tooltipTimeout); // Mouse is over tooltip, cancel hide timer
        })
        .on("mouseout", function() {
             // Mouse left tooltip, start timer to hide it
            tooltipTimeout = setTimeout(() => {
                tooltip.style("opacity", 0).style("pointer-events", "none");
            }, 200);
        });

        // --- Zooming and Panning ---
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4]) // Zoom limits
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svg.call(zoom);

        // Optional: Fit to screen initially
        function fitAndCenter() {
            // Delay slightly to ensure bounds are calculated correctly after render
            setTimeout(() => {
                const bounds = g.node().getBBox();
                const parent = svg.node().parentElement;
                 // Check if parent exists and has dimensions
                if (!parent || !parent.clientWidth || !parent.clientHeight) {
                    console.warn("SVG parent dimensions not available for fitting.");
                    return;
                }

                const fullWidth = parent.clientWidth;
                const fullHeight = parent.clientHeight;
                // Use minY, maxY, minX, maxX calculated earlier for bounds
                const graphWidth = maxY - minY;
                const graphHeight = maxX - minX;
                const width = bounds.width;
                const height = bounds.height;
                const midX = bounds.x + width / 2;
                const midY = bounds.y + height / 2;

                // Handle cases where bounds might be invalid (e.g., no nodes rendered)
                if (!isFinite(graphWidth) || !isFinite(graphHeight) || graphWidth <= 0 || graphHeight <= 0) {
                     console.warn("Invalid graph bounds for fitting.", bounds);
                     return;
                }

                // Add padding to the scale calculation
                const scalePadding = 0.95;
                const scale = Math.min(1.5, scalePadding * Math.min(fullWidth / graphWidth, fullHeight / graphHeight)); // Allow slight zoom in, limit max zoom


                const translate = [
                    fullWidth / 2 - scale * midX,
                    fullHeight / 2 - scale * midY
                ];

                const transform = d3.zoomIdentity
                    .translate(translate[0], translate[1])
                    .scale(scale);

                svg.transition().duration(750).call(zoom.transform, transform);
             }, 150); // Increased delay slightly
        }

       // Call fitAndCenter once
       fitAndCenter();
       // Readjust on resize
       window.addEventListener('resize', fitAndCenter);

    </script>
</body>
</html>
